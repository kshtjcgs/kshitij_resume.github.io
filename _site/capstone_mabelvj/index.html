<!DOCTYPE html>
<link rel="shortcut icon" type="image/png" href="github.png">

<html lang="">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Right Whale call recognition using Convolutional Neural Networks</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="/capstone_mabelvj/">
  <link rel="alternate" type="application/rss+xml" title="Mabel Villalba Jiménez" href="/feed.xml">
  
  

 <!--- <link href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,500,500i,700,700i" rel="stylesheet">-->
  <link href="https://fonts.googleapis.com/css?family=Quicksand:400,700|Raleway+Dots|Raleway:400,700,800,900i|Ubuntu:300,500,700,700i" rel="stylesheet">

  <link rel="shortcut icon" type="image/png" href="/github.png" >
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <a class="site-title" href="/">Mabel Villalba Jiménez</a>

    <nav class="site-nav">
      <span class="menu-icon" onclick = "void(0)"> <!-- onclick = "void(0)" for iOS-->
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>
<!-- Modified to sort! -->
      <div class="trigger">
      
        
          
        
          
          <a class="page-link" href="/">Home</a>
          
        
          
          <a class="page-link" href="/capstone_mabelvj/">Right Whale call recognition using Convolutional Neural Networks</a>
          
        
          
          <a class="page-link" href="/projects/">Other projects</a>
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Right Whale call recognition using Convolutional Neural Networks</h1>
  </header>

  <div class="post-content">
    <h1 id="capstone-project-machine-learning-engineer-nanodegree">Capstone project: Machine Learning Engineer Nanodegree</h1>
<blockquote>
  <p>Code availabe here: <strong><a href="https://github.com/mabelvj/MLNP/tree/master/capstone/code">https://github.com/mabelvj/MLNP/tree/master/capstone/code</a></strong></p>
</blockquote>

<p>Isabel María Villalba Jiménez </p>

<p>Thursday  3<span class="s2">rd</span><span class="s3"> </span>November, 2016</p>

<h1 id="definitioni-definition">1.<a href="#i.-definition">Definition</a></h1>
<hr />

<h2 id="project-overview">1.1. Project Overview</h2>
<hr />

<p>Right whales are one of the most endangered species around the world, with only a few 400 remaining. Many of casualties among them are caused by crashing into boats. One way of avoiding these collisions is to alert ships when whales are detected in the proximity.</p>

<p>In order to do so, Cornell University’s Bioacoustic Research Program, which has extensive experience in identifying endangered whale species, has deployed a 24/7 buoy network to guide ships from colliding with the world’s last 400 North Atlantic right whales (see figure <a href="#img:setup">1</a>).</p>

<p><img src="capstone_report_mabelvj/Image_001.jpg" alt="\label{img:setup}" title="Figure 1: Illustration of the deployment of the buoys in the sea while coexisting with whales" /> </p>

<p><strong>Figure 1: Illustration of the deployment of the buoys in the sea while coexisting with whales</strong> </p>

<p>This work comes from a proposal of the Cornell University’s Bioacoustic Research Program of finding new ways of improving the detection of these mammals through the audio signal of the buoys network. Cornell University provides for the competition a dataset with recordigs made by the buoys. The proposal was made through a Kaggle competition named <a href="https://www.kaggle.com/c/whale-detection-challenge"><span>The Marinexplore and Cornell University Whale Detection Challenge</span></a> [@kagglewhale] <span>“Copyright © 2011 by Cornell University and the Cornell Research Foundation, Inc. All Rights Reserved”</span>.</p>

<h2 id="problem-statement">1.2. Problem Statement</h2>
<hr />

<p>Right whales make a half-dozen types of sounds, but the most characteristic one is the up-call. This type of “contact call”, is a little like small talk– the sound of a right whale going about its day and letting others know it is nearby. In figure <a href="#img:upcall">2</a> it is represented the spectrogram of an up-call which sounds like a deep, rising “whoop” that lasts about a second (sound in [@CornellWeb], other calls in [@CornellWeb2]).</p>

<p><img src="capstone_report_mabelvj/Image_002.jpg" alt="\label{img:upcall}" /></p>

<p><strong>Figure 2: Spectrogram of a rigth whale up-call</strong></p>

<p>The goal of this work is to present a model capable of detecting the right whale’s up-call, which is the most characteristic call of this specie, from the audio detected by the buoys deployed in the sea.</p>

<p>Impressed by the working principle of Convolutional Neural Networks, I decided looking for uses beyond pure image classification. I also had been wondering if anything related to animals and whales could be done. I started looking in the internet and found several Kaggle competitions: one on whale detection through images (<a href="https://www.kaggle.com/c/noaa-right-whale-recognition">Right Whale Recognition</a>), and other on recognizing the North Atlantic Right Whale call (<a href="https://www.kaggle.com/c/whale-detection-challenge"><span>The Marinexplore and Cornell University Whale Detection Challenge</span></a>). Searching for applications of Convolutional Neural Networks in sound recognition, I found an entry related to the <span>The Marinexplore and Cornell University Whale Detection Challenge</span>. In [@Nouriblog] Daniel Nouri proposed to use ConvNets not just to go across the spectrogram of the whale calls, but try to recognize a pattern by simply looking at its image, like a human could. With this proposal he got pretty good results with a very straight forward approach. I decided to give it a try and look for most used ConvNets schemes and see their<br />
performance in this competition.</p>

<p>The <strong>workflow</strong> can be organized as follows:</p>

<ol>
  <li>
    <p>sound samples exploration</p>
  </li>
  <li>
    <p>spectrogram generation and image processing (contrast,<br />
appropriate dimensions…)</p>
  </li>
  <li>
    <p>separation of dataset into training, cross-validation and test<br />
dataset and save into pickle</p>
  </li>
  <li>
    <p>select ConvNets model and adjust parameters</p>

    <ul>
      <li>
        <p>define structure of the ConvNet adequate for the images: depth of layers, and stride and patch size of filters and pooling<br />
layers</p>
      </li>
      <li>
        <p>AUC vs epochs (or training iterations), Error vs epochs, for different batch sizes</p>
      </li>
      <li>
        <p>tune the model using regularization and decaying learning rate</p>
      </li>
    </ul>
  </li>
  <li>
    <p>compare the performance of winning model using the reduced version train and test dataset extracted from the train dataset</p>
  </li>
</ol>

<h2 id="metrics">1.3. Metrics</h2>
<hr />

<p>The main evaluation metric for this project will be that used in the Kaggle competition, this is the <strong>Area Under the Curve (AUC)</strong>, where the Curve is the ROC curve.</p>

<p>The <strong>receiver operating characteristic (ROC)</strong> curve is a graphical plot that illustrates the performance of a binary classifier system as its discrimination threshold is varied. The curve is created by plotting the true positive rate (TPR) against the false positive rate (FPR) at various threshold settings.</p>

<p>The true-positive rate is also known as sensitivity, recall or probability of detection. The false-positive rate is also known as the fall-out or probability of false alarm.</p>

<p>The ROC curve is thus, the sensitivity as a function of fall-out. In general, if the probability distributions for both detection and false alarm are known, the ROC curve can be generated by plotting the cumulative distribution function (area under the probability distribution from $-\infty$ to the discrimination threshold) of the detection probability in the y-axis versus the cumulative distribution function of the false-alarm probability in x-axis (see figure<br />
<a href="#img:ROC">3</a>)[@wikiROC].</p>

<p>Other interesting tool can be the <strong>confusion matrix</strong>, which is a more detailed version of the ROC curve. The confusion matrix is a table that shows the predicted labels for each of the true input labels. Hence, this table shoes true positives (TPs), false positives (FPs), true negatives (TNs) and false negatives (FNs). Each prediction result or instance of the confusion matrix represents a point in the ROC space [@wikiROC].</p>

<p><img src="capstone_report_mabelvj/Image_003.jpg" alt="\label{img:ROC}" /></p>

<p><strong>Figure 3: ROC curve graphic explanation</strong></p>

<p>Another important measure can be the <strong>error rate</strong> vs iterations for different batch sizes. The error rate used can be the percentage of wrong classified samples. This metric is widely used in literature for ConvNets [@Lecun98; @Krizhevsky12] as it gives an insight of the state of training of the network. It is quite common to detect over-training. When this phenomenon occurs, the training error keeps decreasing over time, but the test error goes through a minimum and then starts increasing after a certain number of iteration [@Lecun98].</p>

<h1 id="analysisii-analysis">2.<a href="#ii.-analysis">Analysis</a></h1>
<hr />

<h2 id="data-exploration">2.1. Data Exploration</h2>
<hr />

<p>The dataset used comes from the competition and consists of 30,000 training samples and 54,503 testing samples. Each candidate is a 2-second .aiff sound clip with a sample rate of 2 kHz. The file “train.csv” gives the labels for the train set. Candidates that contain a right whale call have label=1 otherwise, label=0. These clips contain any mixture of right whale calls, non-biological noise, or other whale calls [@CornellWeb; @CornellWeb2].</p>

<p>The training dataset is imbalanced, consisting of 7027 right whale up-calls samples (label=1) and 22973 non right whale up-calls samples (label=0) (figure <a href="#img:train_dataset">4(b)</a>.), with a total of 30000 samples. Test labels are not available in the dataset file and Kaggle will not make it available since the competition is closed. As it will be explained later in the section Model Evaluation and Validation [model-evaluation-and-validation], the number of samples in the training dataset are not enough to provide good amount of data for training, validation and testing. I decided to obtain the labels using<br />
winning models and extend the amount of data available for training. Data distribution is presented in figure <a href="#img:test_dataset">4(b)</a>. The test dataset is also imbalanced, with 13276 right whale up-calls samples (label=1) and 41227 non up-calls samples (label=0), with a total of 54503 samples. As it can be seen, the training and test dataset have more or less the same proportion of data from each label. However, both dataset are quite imbalanced. In order to deal with this problem, I could just balance the samples used (get the same amount of labels from each type) or try to use an algorithm that penalizes this imbalance.</p>

<p>The dataset split will be as follows: <strong>training dataset</strong> is split into training and validation dataset, with respectively, 90% and 10% of the training data, which means 12648 and 1406 samples from the balanced training dataset. This 90-10 split, instead of the usual 80-20 split, is due to the lack of data in the training dataset, what makes to put the efforts in maximizing the amount of data for training. Data from the extended dataset could have been added, but I preferred to keep the training to the true training samples and labels, and not to give any mislabeled data in this process. For testing, labels obtained from the simulation will be used. However, the whole <strong>test dataset</strong> is too big<br />
to evaluate in iterations and it will be reduced to 10000 random samples from the 54503 test samples.</p>

<p><img src="capstone_report_mabelvj/Image_004.jpg" alt="\label{img:train_dataset}" title="(a)" /> <img src="capstone_report_mabelvj/Image_005.jpg" alt="\label{img:test_dataset}" title="(b)" /></p>

<p><strong>Figure 4: (a) Training and (b) test dataset</strong></p>

<h2 id="exploratory-visualization">2.2. Exploratory Visualization</h2>
<hr />

<p>The audio is recorded after the buoys auto-detect the characteristic up-call, what biases the dataset to that kind of calls. Thus, it makes sense to detect only the up-call, which is the most characteristic and most frequently emitted call (details on the deployment of the buoys and how the recordings are made in [@McDonald2002]).</p>

<p>In figure <a href="#img:samples">5</a>, samples corresponding to right-whale up-call (label = 1) show the that the energy of the signal is below 250Hz (see figure <a href="#img:upcall">2</a>) and they exhibit a clear pattern. This fact will help to reduce information processed to that range of frequencies. In the second row, corresponding to negative identifications (label = 0) this pattern is not present. However, some samples from other whale species or corresponding to right-whale making other calls are included in the label 0. This could be the case of sample train6776 in figure <a href="#img:samples">5</a>.</p>

<p>Recordings have a duration of 1.8 seconds and a sampling rate of 2000 Hz. The raw spectrogram of the recordings results in images of 129x23 pixels.</p>

<p><img src="capstone_report_mabelvj/Image_006.jpg" alt="\label{img:samples}" /></p>

<p><strong>Figure 5: Samples for right whale up-call (label 1) and no-right-whale up-call (label 0)</strong></p>

<h2 id="algorithms-and-techniques">2.3. Algorithms and Techniques</h2>
<hr />

<p>Several models have been tried to approach this problem. Algorithms like Linear Discriminant Analysis (LDA), TreeBagger, Decision Trees and Support Vector Machines have been recently applied to the detection of up-calls [@Esfahanian2015].</p>

<p>In order to perform the prediction, I will try to implement well-known and widely implemented models of ConvNets. ConvNets are outstanding at image detection but they do need large amount of data to train well enough and have high computational requirement. Up to now, ConvNets in acoustics have been used for the spectrogram, but I will try a new approach, to detect from the image of the spectrogram as human would do. I will try to check if the suitability of ConvNets for the detection of sound from the the image of the spectrogram [@Nouriblog].</p>

<p>Convolutional Neural Networks (ConvNets) are a type of Neural Networks (NNs) that make the assumption that inputs are images. This allows to encode certain properties into the architecture that make the forward function more efficient to implement and vastly reduce the amount of parameters in the network [@cs231convnets]. ConvNets, like other NNs, are made up of layers. These layers (called hidden layers) transform input 3D volumes to output 3D volumes with some differentiable function that may or may not have parameters [@cs231convnets]. This is an interesting property of ConvNets: layers have neurons arranged in 3 dimensions (width, height and depth) (see figure <a href="#img:cnn">6</a>). </p>

<p><img src="capstone_report_mabelvj/Image_007.jpg" alt="\label{img:cnn}" /></p>

<p><strong>Figure 6: ConvNet 3D structure</strong></p>

<p>There are three main types of layers that are used to build ConvNets [@cs231convnets]:</p>

<ul>
  <li>
    <p>Convolutional Layer (CONV): computes the output of neurons connected to local regions of the input, performing the dot product between their weight and a small region that are connected to. If the input is 3D (i.e. an image with RGB colors) this layer will also be 3-dimensional. Four hyperparameters control the size of the output volume: the depth, filter size, stride, and zero-padding. Depth (D) is related to the number of filters used in the layer, the filter or patch have dimensions (F) (i.e. 2x2) and stride (S) is referred to the displacement of the filter. The amount Zero-padding (P), which allows controlling the spatial size of outputs.</p>
  </li>
  <li>
    <p>Pooling Layer (POOL) (or Subsampling Layer): performs downsampling operation along spatial dimensions. Can be max-pooling (taking the maximum of a region), average-pooling (taking the average of a region) or other types of results from applying a function to a region of the image. It has two main hyperparameters: the spatial extent of the filter or patch where pooling is applied (F) and the stride (S) of this filter.</p>
  </li>
  <li>
    <p>Fully-Connected Layer (FC): is the same type of layer as in NNs.</p>
  </li>
</ul>

<p>Usually, a CONV layer is followed by a Rectified Linear Unit (RELU) layer, which performs an element-wise activation function (i.e. max(0,x), logistic function, tanh).</p>

<p>LeNet is one of the first successful applications of Convolutional Networks, developed by Yann LeCun in the 90s. One of the versions of LeNet is LeNet-5, which is highly used for handwritten and machine-printed character recognition. Figure <a href="#img:lenet5">7</a> shows the structure of the network, composed of 2 convolutional layers, 2 fully connected layers and 2 subsampling or pooling layers. The layers follow the sequence: INPUT -&gt; CONV -&gt; RELU -&gt; SUBS (POOL) -&gt; CONV -&gt; RELU -&gt; SUBS (POOL) -&gt; FC -&gt; RELU -&gt; FC.</p>

<p><img src="capstone_report_mabelvj/Image_008.jpg" alt="\label{img:lenet5}" /></p>

<p><strong>Figure 7: LeNet-5 structure</strong></p>

<p>Other more complex ConvNet is AlexNet, developed by Alex Krizhevsky et al. [@Krizhevsky12]. The AlexNet was submitted to the ImageNet ILSVRC challenge in 2012 and significantly outperformed the second runner-up (top 5 error of 16% compared to runner-up with 26% error). It has a very similar architecture to LeNet, but it is deeper, bigger, and features Convolutional Layers stacked on top of each other (previously it was common to only have a single CONV layer always immediately followed by a POOL layer)[@cs231convnets]. Figure <a href="img:imagenet12">8</a> shows the structure of the network, composed of 5 convolutional layers, 3 fully connected layers and 3 subsampling or pooling layers. The layers follow the sequence: INPUT -&gt; CONV -&gt; RELU -&gt; SUBS -&gt; CONV -&gt; RELU -&gt; SUBS -&gt; CONV -&gt; RELU -&gt; CONV -&gt; RELU -&gt; SUBS -&gt; FC -&gt; RELU -&gt; FC.</p>

<p><img src="capstone_report_mabelvj/Image_009.jpg" alt="\label{img:imagenet12}" /></p>

<p><strong>Figure 8: AlexNet structure</strong></p>

<p>Some parameters need adjustment to adequate the network to this work, like the size of the patch (F) and stride (S) of the convolutional and pooling layers, and also the depth (D) of each convolutional layer. This issue will be discussed in later sections (see section [implementation]).</p>

<h2 id="benchmark">2.4. Benchmark</h2>
<hr />

<p>I will try to compare the performance of popular ConvNets (i.e. LeNet-5 proposed by Lecun [@Lecun98] or AlexNet, the winner of the 2010 and 2012 <span>ImageNet Large Scale Visual Recognition Competition (ILSVRC)</span> proposed by Krizhevsky [@Krizhevsky12; @Krizhevsky2010]) with the performance of the winning model of the competition which is based on Gradient Boosting (SluiceBox: <a href="https://github.com/nmkridler/moby">Github</a>) and the Daniel Nouri’s model based on Krizhevsky’s 2012 ILSVRC ConvNet model [@Krizhevsky12] <a href="https://speakerdeck.com/dnouri/practical-deep-neural-nets-for-detecting-marine-mammals/">(source)</a> , which first inspired this work.</p>

<p>The Area Under the Curve (AUC) (see the Evaluation metrics section [metrics]) of these models in the public leaderboard was:</p>

<ul>
  <li>
    <p>SluiceBox: 0.98410 (1st position)</p>
  </li>
  <li>
    <p>Nouri: 0.98061 (6th position with 1/4 times the submission of<br />
the winner)</p>
  </li>
</ul>

<p>Nevertheless, I will not be able to compare the performance of my models to these results. The reason is that I do not have the test labels and also, the public leaderboard data test used is slightly different for each participant. I will try two different approaches:</p>

<ol>
  <li>
    <p>assuming that there are enough complete data samples (train dataset), trying to increase the accuracy as much as possible</p>
  </li>
  <li>
    <p>assuming the predictions generated by the winning model as test labels and them as reference to compare our model with</p>
  </li>
</ol>

<p>Consequently, it will not be easy to truly compare the performance of this model with the ones in the competitions. Taking into consideration all the factors explained above, 0.95 AUC can be a really good value to achieve.</p>

<h1 id="methodologyiii-methodology">3. <a href="#iii.-methodology">Methodology</a></h1>
<hr />

<h2 id="data-preprocessing">3.1. Data Preprocessing</h2>
<hr />

<p>The processing of the images will consist in the usual mean subtraction and normalization (division by standard deviation) [@cs231preprocessing]. The function used for this purpose is the StandardScaler from the preprocessing module from sklearn [@sklearn_standard_scaler]. The result of this process applied to images in figure <a href="#img:samples">5</a> is presented in figure <a href="#img:samples_unprocessed">9</a>.</p>

<p><img src="capstone_report_mabelvj/Image_010.jpg" alt="\label{img:samples_unprocessed}" /></p>

<p><strong>Figure 9: Samples after mean subtraction and division by standard deviation for right whale up-call (label 1) and no-right-whale up-call (label 0)</strong></p>

<p>However, after applying this processing, images are not clear enough and energy where up-calls are contained is very low. In order to make them more visible, images in figure [img:samples] are first processed applying log10 and then normalized subtracting mean and dividing by the standard deviation. This method is widely used in spectrogram visualization when there is to rescale images, making minimum values more visible.</p>

<p><img src="capstone_report_mabelvj/Image_011.jpg" alt="\label{img:samples_log10}" /></p>

<p><strong>Figure 10: Processed samples after log10 and mean subtraction and normalization for right whale up-call (label 1) and no-right-whale up-call (label 0)</strong></p>

<p>As it was commented previously, recordings have a duration of 1.8 seconds and a sampling rate of 2000Hz. The raw spectrogram of the recordings result in images of 129x23 pixels. Two problems arise from this: the excess of redundant information in frequencies not important for the detection of the up-call and the limitation in terms of the image of being processed by the network.</p>

<p>In order to solve the first problem, the frequency range will be limited 0-250 Hz, what will result in images of size 33x23 px. Still, this is not good for a ConvNet with lots of convolutions and pooling. It is necessary to resize the image and a good number is multiple of 2. Hence, I will choose images to be 32x32 px and will obtain additional pixels using interpolation.</p>

<p><img src="capstone_report_mabelvj/Image_012.jpg" alt="\label{img:samples_reshaped}" /></p>

<p><strong>Figure 11: Samples reduced to 32x32 pixels after log10 and mean subtraction and normalization for right whale up-call (label 1) and no-right-whale up-call (label 0).</strong></p>

<h2 id="implementation">3.2. Implementation</h2>
<hr />

<p>The model implemented is LeNet-5 (see figure [img:lenet5]). The only<br />
difference in the F6 layer, which has been removed. This layer is used<br />
for the detection of ASCII characters in 7x12 bitmaps, but this network<br />
does not intend to do so, it just needs to detect right-whale up-call or<br />
not.</p>

<p>The structure of the network is as follows (F= Filter, S= Stride, D=<br />
Depth):</p>

<ul>
  <li>
    <p>INPUT layer: 32x32 px image in gray scale represented with 8-bit number (0-255 levels).</p>
  </li>
  <li>
    <p>C1 - CONV layer: F = 5x5, S = 1, D = 6</p>
  </li>
  <li>
    <p>S2 - POOL layer: F = 2x2, S = 2, D = 6</p>
  </li>
  <li>
    <p>C3 - CONV layer: F = 5x5, S = 1, D = 16</p>
  </li>
  <li>
    <p>S4 - POOL layer: F = 2x2, S = 2, D = 16</p>
  </li>
  <li>
    <p>C5 - CONV layer: F = 5x5, S = 1, D = 120</p>
  </li>
  <li>
    <p>F5 - FC layer: neurons= 120 x 2, one per label(considering label 0 and label 1)</p>
  </li>
</ul>

<p>The training is performed using mini-batch gradient descent, which is a version of the true gradient descent (combines batch and stochastic gradient descent), used when the data amount is quite high. It iterates over batches of n samples in order to approach the minimum of the cost function step by step (epochs). Mini-batch gradient descent reduces the variance of the parameter updates, which can lead to more stable convergence. It also can make use of highly optimized matrix optimizations common to state-of-the-art deep learning libraries that make computing the gradient with respect to a mini-batch very efficient [@ruderweb].</p>

<p>The gradient descent main parameter is the learning rate ($\alpha$). The learning rate expresses the speed of convergence of the gradient descent. Large learning rates lead to faster convergence but it may miss the minimum and not converge properly. Low learning rates lead to a better convergence point, but it is slower, requiring more steps and more memory allocation. A good compromise is to use a decaying learning rate: high values for the first epochs to accelerate the initial convergence and then smaller ones to slow it down.</p>

<p>Regularization is a common way to prevent over-fitting and the most used method is L2 regularization. This type of regularization penalizes the square magnitude of all parameters, adding the term $\frac{1}{2}\lambda \omega ^2$ to the prediction, for $\lambda$ the regularization strength [@cs231convnets]. In this work L2 regularization will be used to control the over-fitting.</p>

<p>The network has been implemented making use of Tensorflow, using the basic of ConvNets explained in the Udacity Deep Learning Course [@deepgithub] and then extending the functionality to more complex networks.</p>

<h2 id="refinement">3.3. Refinement</h2>
<hr />

<p>The process followed has been one the iteration over different parameters to obtain the best combination.</p>

<h3 id="select-batch-size">Select batch-size</h3>

<p>In order to select the proper batch size simulations have been performed for different learning rates. After many simulations, I have observed that there must be a trade-off between batch-size and instability. The bigger the batch, the stabler the curves, but the poorer the performance since the number of epochs is smaller. The batch size must be big enough to provide a less noisy curve but small enough to give good values of prediction.</p>

<p>From figure <a href="#img:batch\_comparasion">12(a)</a> it seems that a good compromise value is a batch size of 5.</p>

<p><img src="capstone_report_mabelvj/Image_014.jpg" alt="\label{img:batch_comparasion}" /> <img src="capstone_report_mabelvj/Image_015.jpg" alt="\label{img:learning_rate}" /></p>

<p><strong>Figure 12: (a) Error curve for the validation dataset,for different batch sizes and a learning rate <em>α</em>=0.0005 and (b) AUC for the validation dataset, for different learning rates and a batch size = 5</strong></p>

<h3 id="select-learning-rate">Select learning rate</h3>

<p>Secondly, for a fixed batch size , the cost has been calculated for different learning rates. Learning rates too big may not find the minimum and converge too fast. Small learning rate may be too slow and not fast enough for a small dataset like the one in this work. A compromise value must be chosen, showing a slope good that guarantees convergence. Figure <a href="#img:learning_rate">12(b)</a> shows that for the selected batch size of 5, a learning rate $\alpha$ of 0.0005 seems like a good value. Figure <a href="#img:batch">13</a> shows that there is not over-fitting, since there is no gap between the training curve and the validation and test curves.</p>

<p><img src="capstone_report_mabelvj/Image_016.jpg" alt="\label{img_batch}" /></p>

<p><strong>Figure 13: AUC for batch size = 5 and learning rate <em>α</em>=0.0005</strong></p>

<h3 id="select-regularization">Select regularization</h3>

<p>Finally, for fixed batch size and learning rate, the AUC has been calculated for regularization parameters. Regularization is a good way to limit over-fitting, allowing the model to generalize better. Figure <a href="#img:regularization_1">14</a> shows the AUC curve for different values of the regularization parameters. Figure <a href="#img:regularization_1">14(a)</a> shows that a good value for the regularization parameter can is near 0.95, and figure <a href="#img:regularization_2">14(b)</a> shows that for the selected batch size of 5 and learning rate of 0.0005 a good regularization value is 0.97, since it allows to reach a greater AUC.</p>

<p><img src="capstone_report_mabelvj/Image_017.jpg" alt="\label{img:regularization_1}" /> <img src="capstone_report_mabelvj/Image_018.jpg" alt="\label{img:regularization_2}" /></p>

<p><strong>Figure 14: AUC in the validation dataset for different regularization values, batch size = 5 and learning rate <em>α</em>=0.0005</strong></p>

<h1 id="resultsiv-results">4. <a href="#iv.-results">Results</a></h1>
<hr />

<h2 id="model-evaluation-and-validation">4.1. Model Evaluation and Validation</h2>
<hr />

<p>The model used is the LeNet-5 [@Lecun98]. Figure <a href="#img:result">15</a> shows the AUC and the error for different epochs, achieving 0.944 AUC in the test set (and up to 0.958 depending on the test split) and an error of 12% when reaching 2500 epochs, batch size = 5, learning rate $\alpha$=<span>0.0005</span> and regularization parameter = 0.97. Figure <a href="#img:result">15</a> shows there is no over-fitting, since validation and test curve follow the training curve. This is clearly a good result given the limitations related to data in this work previously explained in section [data-exploration] and is very close to the objective of 0.95 AUC stated in [benchmark].</p>

<p><img src="capstone_report_mabelvj/Image_019.jpg" alt="image" title="(a)" />  <img src="capstone_report_mabelvj/Image_020.jpg" alt="image" title="(b)" /></p>

<p><strong>Figure 15: (a) AUC and (b) error for the train validation and test dataset, for the final model batch size = 5, learning rate <em>α</em>=0.0005and regularization parameter = 0.97 \label{img:result}</strong></p>

<p>One problem I faced when training the model was the limitation in terms of data samples for training which reduced the maximum AUC obtained. In order to solve it, labels for the test dataset have been obtained using the evaluations from the winning model as true labels (SluiceBox: 0.98410 AUC). This has allowed o increase the volume of data samples available to train the model and hence, increase its performance. I have taken this decision after taking into consideration the processed of obtaining the samples. The sounds were firstly recorded when a buoy detected an up-all in the area. Afterwards, samples were labeled by human ear. This leads to a lot of mislabeled samples (as mentioned in [@Nouriblog]), and gives the intuition that using the labels from the prediction of a good model as test dataset, freeing samples for training, can be more good than harm. This has allowed to extend the available data for training (from around 8000 to 12500 samples from the balanced dataset of 14000 samples) and have available 54503 samples from the unbalanced testing dataset for testing, though it was used 10000 random samples for computational issues. This dataset was not artificially balanced just to try how the training would perform in a real world with little samples from one label when compared to the other one.</p>

<h2 id="justification">4.2. Justification</h2>
<hr />

<p>This work has shown the use of simple ConvNet for audio recognition, obtaining good performance with an AUC of up to 0.958, whereas more complex models as SluiceBox obtained 0.98410 AUC and Nuori 0.98061.</p>

<p>One of the advantages of simpler networks relies upon the reduction of time required for training the model, resulting in fewer computer requirements. With a vast dataset, the system would increase significantly the performance and equal those with more complex structure, making it a simple, yet robust choice.</p>

<h1 id="conclusionv-conclusion">5. <a href="#v.-conclusion">Conclusion</a></h1>
<hr />

<h2 id="free-form-visualization">5.1. Free-Form Visualization</h2>
<hr />

<p>In this section I will try to give an insight of the network, presenting, as it is frequently done, the characteristics of the first layer. Figure <a href="#img:weights">16(a)</a> it is presented the evolution of the filters of the first CONV layer (F=5x5) with depth 6 (D=6). These filters are the ones convoluting and sweeping through the image and contain the weights fond the CONV layer neurons. It is clear how, due to backpropagation and minimization of the cost function, weights are changed and they evolve to new and more adequate values for prediction. In fact, the six filters start very undefined and they adapt to their final value.</p>

<p>Figure <a href="#img:biases">16(b)</a> shows the evolution of the biases with the number of epochs and how they tend to stabilize. These biases are the biases of the CONV layer and they change to minimize the cost function.</p>

<p><img src="capstone_report_mabelvj/Image_021.jpg" alt="\label{img:biases}" /> <img src="capstone_report_mabelvj/Image_022.jpg" alt="\label{img:weights}" /></p>

<p><strong>Figure 16: (a) Weights and (b) biases of the first layer with 6 filters of depth every 500 epochs for batch size=5, learning rate <em>α</em>=0.0005and regularization parameter= 0.97</strong></p>

<p>Finally, figure <a href="#img:activation">16</a> shows the output every 500 epochs for some samples. It is not clear, but in some of the squares it can be seen the shape of an up-call.</p>

<p><img src="capstone_report_mabelvj/Image_023.jpg" alt="\label{img:activation}" /></p>

<p><strong>Figure 17: Activation of the first layer with 6 filters of depth every 500 epochs for batch size=5 and learning rate <em>α</em>=0.0005</strong></p>

<h2 id="reflection">5.2. Reflection</h2>
<hr />

<p>In this project, it is presented how simple ConvNets can be used to label data from the image of the spectrogram, as it in many classification problems. More complex networks may achieve better results, but for an image of 32x32px, I prefer to take the strategy: the simpler, the better.</p>

<p>In this case, the use of LeNet-5 has given a 0.44-0.958 AUC, which is really good given the low complexity of the network.</p>

<h2 id="improvement">5.3. Improvement</h2>
<hr />

<p>In this work, the problem is to recognize a simple and very specific spectrogram pattern from in a form of an image. A good rule of thumb for this is the simpler, the better and LeNet-5 achieves good performance with a simple structure.</p>

<p>The complexity of the model should not be the focus, since like in any Machine Learning problem, the most important factor is the amount of data. Collecting more samples and extending the training would make LeNet-5 a good competitor against other models achieving better performance with over-complicated models.</p>

<p>Once resolved the issue with the amount of data, more complex models are good start points to increase the performance and achieve better results and compare the trade-off between complexity with results. Good examples of models to try are AlexNet [@Krizhevsky12] or GoogLeNet [@Szegedy16]. Dropout has not been applied in this work, since the network has lots of max-pooling layers and regularization, and in these cases, the use of dropout is not clear. Introducing dropout could be a good option to try. Also, methods to make faster training, as Batch Normalization may lead to better results [@szegedy15batch].</p>

<h2 id="references">References</h2>

<p>[@kagglewhale] Kaggle. The Marinexplore and Cornell University Whale Detection<br />
Challenge. URL: <a href="https://www.kaggle.com/c/whale-detection-challenge">https://www.kaggle.com/c/whale-detection-challenge</a></p>

<p>[@CornellWeb] Cornell Bioacoustics Research Program. Right Whale’s Up-Call,<br />
Cornell Bioacoustics Resear] URL: <a href="http://www.listenforwhales.org/page.aspx?pid=432">http://www.listenforwhales.org/page.aspx?pid=432</a></p>

<p>[@CornellWeb2] Cornell Bioacoustics Research Program. More Right Whale calls, .<br />
URL: <a href="http://www.listenforwhales.org/page.aspx?pid=442">http://www.listenforwhales.org/page.aspx?pid=442</a></p>

<p>[@Nouriblog] Daniel Nouri. Using deep learning to listen for whales — Daniel<br />
Nouri’s Blog. URL: <a href="http://danielnouri.org/notes/2014/01/10/using-deep-learning-to-listen-for-whales/">http://danielnouri.org/notes/2014/01/10/using-deep-learning-to-listen-for-whales/</a></p>

<p>[@WikiROC] the free encyclopedia. Receiver OperatingCharacteristic (ROC).<br />
URL: <a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">https://en.wikipedia.org/wiki/Receiver_operating_characteristic</a></p>

<p>[@wikiwand] Wikiwand. Receiver operating characteristic. URL: <a href="http://www.wikiwand.com/it/Receiver_operating_characteristic">http://www.wikiwand.com/it/Receiver_operating_characteristic</a></p>

<p>[@Lecun98] Yann LeCun, Léon Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to document recognition.]()<em>Proc. IEEE</em>, 86(11):2278–2323, 1998. ISSN 00189219. doi: 10.1109/5.726791.</p>

<p>[@Krizhevsky12] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. ImageNet<br />
Classification with Deep Convolutional Neural Networks.<em>Adv. Neural Inf. Process. Syst.</em>, pages 1–9, 2012. ISSN 10495258. doi: <a href="http://dx.doi.org/10.1016/j.protcy.2014.09.007">http://dx.doi.org/10.1016/j.protcy.2014.09.007.</a></p>

<p>[@McDonald2002] M A McDonald and S E Moore. Calls recorded from North Pacific<br />
right whales (<em>Eubalaena japonica</em>) in the eastern Bering Sea. <em>J. Cetacean Res. Manag.</em>[, 4(3):261–266, 2002. ISSN 1561-0713. URL: (http://www.afsc.noaa.gov/nmml/PDF/rightcalls.pdf)<a href="http://www.afsc.noaa.gov/nmml/PDF/rightcalls.pdf">http://www.afsc.noaa.gov/nmml/PDF/rightcalls.pd</a></p>

<p>[@Esfahanian2015] Mahdi Esfahanian, Hanqi Zhuang, Nurgun Erdol, Edmund Gerstein,<br />
Computer Science, and Boca Raton. Comparison of Two Methods for Detection of North Atlantic Right.<em>Ieee</em>, pages 559–563, 2015.</p>

<p>[@cs231convnets] Johnson Justin Karpathy Andrej. CS231n Convolutional Neural<br />
Networks for Visual Recognition. URL: <a href="http://cs231n.github.io/">http://cs231n.github.io/</a></p>

<p>[@Krizhevsky2010] Alex Krizhevsky and G Hinton. Convolutional deep belief networks on cifar-10.<em>Un- publ. Manuscr.</em>, pages 1–9, 2010.</p>

<p>[@cs231preprocessing] Johnson Justin Karpathy Andrej. CS231n Convolutional Neural Networks for Visual Recognition. URL: <a href="http://cs231n.github.io/neural-networks-2/">http://cs231n.github.io/neural-networks-2/</a></p>

<p>[@sklearn_standard_scaler] sklearn.preprocessing.StandardScaler — scikit-learn 0.18 documentation. URL: <a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html">http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html</a></p>

<p>[@ruderweb] Sebastian Ruder. An overview of gradient descent optimization algorithms. sep 2016. URL: <a href="http://sebastianruder.com/optimizing-gradient-descent/">http://sebastianruder.com/optimizing-gradient-descent/</a></p>

<p>[@deepgithub] Udacity. Deep Learning Course Repository. URL: <a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/udacity">https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/udacity</a></p>

<p>[@Szegedy16] Christian Szegedy, Wei Liu, Yangqing Jia, Pierre Sermanet, Scott<br />
Reed, Dragomir Anguelov, Dumitru Erhan, Vincent Vanhoucke, and Andrew Rabinovich. Going deeper with convolutions. In *Proc. IEEE Comput. Soc. Conf. Comput. Vis. Pattern Recognit., volume 07-12-June, pages 1–9, sep 2015. ISBN 9781467369640. doi: 10.1109/CVPR.2015.7298594. URL: <a href="http://arxiv.org/abs/1409.4842">http://arxiv.org/abs/1409.4842</a></p>

<p>[@szegedy15batch] Sergey Ioffe and Christian Szegedy. Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift. <em>arXiv:1502.03167</em>[, pages 1–11, 2015. ISSN 0717-6163. doi: 10.1007/s13398-014-0173-7.2. URL: <a href="http://arxiv.org/abs/1502.03167">http://arxiv.org/abs/1502.03167</a></p>


  </div>

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Mabel Villalba Jiménez</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
         <!-- <li>
            
              Mabel Villalba Jiménez
            
            </li>-->
            
            Contact: 
            <li><a href="mailto:mabelvj@gmail.com"> mabelvj@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/mabelvj"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">mabelvj</span></a>

          </li>
          
          
          <li>
            <a href="https://linkedin.com/in/mabelvj"><span class="icon icon--linkedin"><svg viewBox="0 50 512 512" width="16px" height="16px"><path fill="#828282" d="M150.65,100.682c0,27.992-22.508,50.683-50.273,50.683c-27.765,0-50.273-22.691-50.273-50.683 C50.104,72.691,72.612,50,100.377,50C128.143,50,150.65,72.691,150.65,100.682z M143.294,187.333H58.277V462h85.017V187.333z M279.195,187.333h-81.541V462h81.541c0,0,0-101.877,0-144.181c0-38.624,17.779-61.615,51.807-61.615 c31.268,0,46.289,22.071,46.289,61.615c0,39.545,0,144.181,0,144.181h84.605c0,0,0-100.344,0-173.915 s-41.689-109.131-99.934-109.131s-82.768,45.369-82.768,45.369V187.333z"/></svg>
</span><span class="username">mabelvj</span></a>

          </li>
          

          
        </ul>
      </div>

      <!--<div class="footer-col footer-col-3">
        <p>Projects and stuff</p>
      </div>-->
    </div>

  </div>

</footer>


  </body>

</html>
